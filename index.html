<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Codem's Study Hub</title>
    <style>
        :root {
            --primary-bg: #0a0a14;
            --secondary-bg: #12122a;
            --card-bg: #1a1a3a;
            --accent-blue: #00aaff;
            --accent-blue-dark: #0088cc;
            --text-primary: #ffffff;
            --text-secondary: #ccccff;
            --success: #00cc88;
            --error: #ff3366;
            --info-rep: #ff9966;
            --multimedia: #9966cc;
            --files: #66cc99;
            --form-color: #ffcc66;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, var(--primary-bg), var(--secondary-bg));
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0, 170, 255, 0.2);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(to right, var(--accent-blue), #00ddff);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 10px rgba(0, 170, 255, 0.5);
        }
        
        .topic-filter {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .topic-btn {
            background: var(--card-bg);
            color: var(--text-secondary);
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            font-size: 0.9rem;
        }
        
        .topic-btn:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }
        
        .topic-btn.active {
            box-shadow: 0 0 10px currentColor;
        }
        
        .topic-btn.info-rep {
            background-color: var(--info-rep);
            color: var(--primary-bg);
        }
        
        .topic-btn.multimedia {
            background-color: var(--multimedia);
            color: var(--primary-bg);
        }
        
        .topic-btn.files {
            background-color: var(--files);
            color: var(--primary-bg);
        }
        
        .topic-btn.form {
            background-color: var(--form-color);
            color: var(--primary-bg);
        }
        
        .topic-btn.all {
            background: var(--accent-blue);
            color: var(--primary-bg);
        }
        
        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .tab-btn {
            background: var(--card-bg);
            color: var(--text-secondary);
            border: none;
            padding: 12px 24px;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }
        
        .tab-btn:hover {
            background: rgba(0, 170, 255, 0.2);
            transform: translateY(-2px);
        }
        
        .tab-btn.active {
            background: var(--accent-blue);
            color: var(--primary-bg);
            box-shadow: 0 0 15px var(--accent-blue);
        }
        
        .tab-btn.form {
            background: var(--card-bg);
            color: var(--text-secondary);
        }
        
        .tab-btn.form.active {
            background: var(--form-color);
            color: var(--primary-bg);
            box-shadow: 0 0 15px var(--form-color);
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        
        .content-section {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            display: none;
            max-height: calc(100vh - 250px);
            overflow-y: auto;
        }
        
        .content-section.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        h2 {
            color: var(--accent-blue);
            margin-bottom: 20px;
            font-size: 1.8rem;
        }
        
        .flashcard {
            perspective: 1000px;
            height: 250px;
            margin: 20px 0;
            cursor: pointer;
        }
        
        .flashcard-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }
        
        .flashcard.flipped .flashcard-inner {
            transform: rotateY(180deg);
        }
        
        .flashcard-front, .flashcard-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            border-radius: 15px;
            background: linear-gradient(145deg, #1f1f4a, #25255a);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
        }
        
        .flashcard-back {
            transform: rotateY(180deg);
            text-align: left;
            justify-content: flex-start;
        }
        
        .term {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--accent-blue);
        }
        
        .definition {
            font-size: 1.2rem;
            color: var(--text-primary);
        }
        
        .formula {
            background: rgba(0, 170, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 1.1rem;
        }
        
        .example {
            color: var(--text-secondary);
            font-style: italic;
            margin-top: 10px;
        }
        
        .nav-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        
        button {
            background: var(--accent-blue);
            color: var(--primary-bg);
            border: none;
            padding: 12px 20px;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }
        
        button:hover {
            background: var(--accent-blue-dark);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 170, 255, 0.4);
        }
        
        .question {
            background: linear-gradient(145deg, #1f1f4a, #25255a);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
        }
        
        .options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }
        
        .option {
            background: var(--secondary-bg);
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .option:hover {
            background: rgba(0, 170, 255, 0.2);
        }
        
        .option.selected {
            background: var(--accent-blue);
            color: var(--primary-bg);
        }
        
        .matching-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .match-item {
            background: linear-gradient(145deg, #1f1f4a, #25255a);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .match-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 170, 255, 0.3);
        }
        
        .match-item.selected {
            opacity: 0.6;
            background: rgba(0, 170, 255, 0.2);
            border: 2px solid var(--accent-blue);
        }
        
        .text-input {
            width: 100%;
            background: var(--secondary-bg);
            border: 2px solid var(--accent-blue);
            border-radius: 10px;
            padding: 15px;
            color: var(--text-primary);
            font-size: 1.1rem;
            margin-bottom: 15px;
        }
        
        .result {
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            display: none;
        }
        
        .correct {
            background: rgba(0, 204, 136, 0.2);
            border: 2px solid var(--success);
        }
        
        .incorrect {
            background: rgba(255, 51, 102, 0.2);
            border: 2px solid var(--error);
        }
        
        .revision-item {
            background: linear-gradient(145deg, #1f1f4a, #25255a);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
        }
        
        .revision-term {
            color: var(--accent-blue);
            font-size: 1.5rem;
            margin-bottom: 10px;
        }

        .progress-info {
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.1rem;
            color: var(--text-secondary);
        }

        .knowledge-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }

        .btn-know {
            background: var(--success);
        }

        .btn-dont-know {
            background: var(--error);
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: var(--secondary-bg);
            border-radius: 5px;
            margin: 15px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--success);
            width: 0%;
            transition: width 0.3s ease;
        }

        .session-stats {
            text-align: center;
            margin-top: 15px;
            color: var(--text-secondary);
        }
        
        .tag-indicator {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            margin-left: 8px;
            vertical-align: middle;
        }
        
        .tag-info-rep {
            background-color: var(--info-rep);
            color: var(--primary-bg);
        }
        
        .tag-multimedia {
            background-color: var(--multimedia);
            color: var(--primary-bg);
        }
        
        .tag-files {
            background-color: var(--files);
            color: var(--primary-bg);
        }
        
        .tag-form {
            background-color: var(--form-color);
            color: var(--primary-bg);
        }

        /* Form Section Styles */
        .form-container {
            width: 100%;
            height: 600px;
            overflow: hidden;
            border-radius: 10px;
            margin-top: 20px;
        }
        
        .form-iframe {
            width: 100%;
            height: 100%;
            border: none;
            background-color: white;
        }
        
        .form-note {
            text-align: center;
            margin-top: 15px;
            color: var(--text-secondary);
            font-style: italic;
        }
        
        /* Revision Section Styles */
        .revision-property {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }
        
        .revision-property-title {
            font-weight: bold;
            color: var(--accent-blue);
            margin-bottom: 5px;
        }

        @media (max-width: 768px) {
            .options {
                grid-template-columns: 1fr;
            }
            
            .matching-container {
                grid-template-columns: 1fr;
            }

            .knowledge-buttons {
                flex-direction: column;
            }
            
            .flashcard {
                height: 200px;
            }
            
            .term {
                font-size: 1.5rem;
            }
            
            .definition {
                font-size: 1rem;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            h2 {
                font-size: 1.5rem;
            }
            
            .content-section {
                max-height: calc(100vh - 200px);
                padding: 15px;
            }
            
            .topic-btn {
                font-size: 0.8rem;
                padding: 6px 12px;
            }
            
            .form-container {
                height: 500px;
            }
        }

        @media (max-width: 480px) {
            .tabs {
                flex-direction: column;
                align-items: center;
            }
            
            .tab-btn {
                width: 100%;
                margin-bottom: 5px;
            }
            
            .flashcard {
                height: 180px;
            }
            
            .term {
                font-size: 1.3rem;
            }
            
            .nav-buttons {
                flex-direction: column;
                gap: 10px;
            }
            
            .nav-buttons button {
                width: 100%;
            }
            
            header {
                padding: 15px;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            body {
                padding: 10px;
            }
            
            .topic-filter {
                gap: 5px;
            }
            
            .topic-btn {
                font-size: 0.7rem;
                padding: 5px 10px;
            }
            
            .form-container {
                height: 400px;
            }
        }

        /* Orientation-specific adjustments */
        @media (max-height: 600px) and (orientation: landscape) {
            .content-section {
                max-height: calc(100vh - 180px);
            }
            
            .flashcard {
                height: 180px;
            }
            
            header {
                padding: 10px;
                margin-bottom: 15px;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            .form-container {
                height: 350px;
            }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--secondary-bg);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--accent-blue);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-blue-dark);
        }
    </style>
</head>
<body>
    <header>
        <h1>Codem's Study Hub</h1>
        <p>Master Your Classes Easily</p>
    </header>
    
    <div class="container">
        <!-- Topic Filter Section -->
        <div class="topic-filter">
            <button class="topic-btn all active" data-topic="all">All Topics</button>
            <button class="topic-btn info-rep" data-topic="Information Representation">Information Representation</button>
            <button class="topic-btn multimedia" data-topic="Multimedia">Multimedia</button>
            <button class="topic-btn files" data-topic="Files">Files</button>
            <button class="topic-btn form" data-topic="Form">Contribute to Website</button>
        </div>
        
        <div class="tabs">
            <button class="tab-btn active" data-tab="flashcards">Flashcards</button>
            <button class="tab-btn" data-tab="multiple-choice">Multiple Choice</button>
            <button class="tab-btn" data-tab="matching">Matching</button>
            <button class="tab-btn" data-tab="text-based">Text Input</button>
            <button class="tab-btn" data-tab="revision">Revision</button>
            <button class="tab-btn form" data-tab="quiz-form">Contribute to Website</button>
        </div>
        
        <!-- Flashcards Section -->
        <div id="flashcards" class="content-section active">
            <h2>Flashcards</h2>
            <div class="progress-info">
                <span id="card-counter">Card 1 of 30</span>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div class="flashcard">
                <div class="flashcard-inner">
                    <div class="flashcard-front">
                        <div class="term" id="current-term">Binary Coded Decimal (BCD)</div>
                        <p>Click to flip</p>
                    </div>
                    <div class="flashcard-back">
                        <div class="definition" id="current-definition">Binary representation where each positive denary digit is represented by a sequence of 4 bits (nibble).</div>
                        <div class="formula" id="current-formula"></div>
                        <div class="example" id="current-example"></div>
                    </div>
                </div>
            </div>
            <div class="knowledge-buttons">
                <button class="btn-know" id="know-btn">I Know This</button>
                <button class="btn-dont-know" id="dont-know-btn">I Don't Know</button>
            </div>
            <div class="nav-buttons">
                <button id="prev-card">Previous</button>
                <button id="next-card">Next</button>
            </div>
            <div class="session-stats" id="session-stats">
                Known: 0/30 | To Review: 0
            </div>
        </div>
        
        <!-- Multiple Choice Section -->
        <div id="multiple-choice" class="content-section">
            <h2>Multiple Choice Questions</h2>
            <div class="question">
                <p id="mc-question">What is Binary Coded Decimal (BCD)?</p>
                <div class="options" id="mc-options">
                    <div class="option" data-correct="true">Binary representation where each positive denary digit is represented by a sequence of 4 bits</div>
                    <div class="option">A method to represent signed integers in binary</div>
                    <div class="option">A number system with digits 0-9 and letters A-F</div>
                    <div class="option">A character encoding standard</div>
                </div>
            </div>
            <button id="check-mc">Check Answer</button>
            <div class="result" id="mc-result"></div>
            <div class="nav-buttons">
                <button id="prev-mc">Previous</button>
                <button id="next-mc">Next</button>
            </div>
        </div>
        
        <!-- Matching Section -->
        <div id="matching" class="content-section">
            <h2>Matching Exercise</h2>
            <p>Click items from the left column to match with items on the right</p>
            <div class="matching-container">
                <div class="matching-column" id="terms-column">
                    <!-- Will be populated by JavaScript -->
                </div>
                <div class="matching-column" id="definitions-column">
                    <!-- Will be populated by JavaScript -->
                </div>
            </div>
            <button id="check-matching">Check Answers</button>
            <div class="result" id="matching-result"></div>
            <button id="new-matching-set" style="margin-top: 15px;">New Set</button>
        </div>
        
        <!-- Text Input Section -->
        <div id="text-based" class="content-section">
            <h2>Text Input Exercise</h2>
            <div class="question">
                <p id="text-question">What is Binary Coded Decimal (BCD)?</p>
                <input type="text" class="text-input" id="text-answer" placeholder="Type your answer here...">
                <button id="check-text">Check Answer</button>
                <div class="result" id="text-result"></div>
                <div class="correct-answer" id="correct-answer"></div>
            </div>
            <div class="nav-buttons">
                <button id="prev-text">Previous</button>
                <button id="next-text">Next</button>
            </div>
        </div>
        
        <!-- Revision Section -->
        <div id="revision" class="content-section">
            <h2>Revision Materials</h2>
            <div id="revision-content">
                <!-- Content will be generated by JavaScript -->
            </div>
        </div>
        
        <!-- Quiz Form Section -->
        <div id="quiz-form" class="content-section">
            <h2>Contribute to Website <span class="tag-indicator tag-form">External</span></h2>
            <p>Please fill out the form below to contribute to our website.</p>
            
            <div class="form-container">
                <iframe class="form-iframe" src="https://docs.google.com/forms/d/e/1FAIpQLSdxZPupUKB018u68kLJcfN8_CM3Tgn_VB1bW3sAszy9z9Ft9A/viewform?embedded=true" frameborder="0" marginheight="0" marginwidth="0">Loading…</iframe>
            </div>
            
            <div class="form-note">
                <p>Note: This form is hosted externally by Google. Your responses will be submitted to the form owner.</p>
            </div>
        </div>
    </div>

    <script>
        // Study data with tags
        const studyData = [
            {
                term: "Binary Coded Decimal (BCD)",
                definition: "Binary representation where each positive denary digit is represented by a sequence of 4 bits (nibble).",
                details: "Only digits 0-9 are converted to BCD because digits greater than 9 are not valid in BCD. If a nibble is greater than 9, add 6 (0110) to correct the BCD representation.",
                example: "To represent 429 in BCD: 4 = 0100, 2 = 0010, 9 = 1001, concatenated as 0100 0010 1001.",
                applications: "Used in electronic devices displaying numbers (e.g., calculators, digital clocks), accurately measuring decimal fractions, coding denary numbers electronically, and storing date/time in BIOS where conversion with denary is easier.",
                benefits: "More straightforward to convert between BCD and denary; less complex to encode and decode for programmers; easier for digital equipment to display information; can represent monetary values exactly.",
                tags: [
                    "Information Representation"
                ]
            },
            {
                term: "Two's Complement",
                definition: "A method to represent signed integers in binary by using the most significant bit (MSB) as a sign bit.",
                conversion: "To convert a negative number (e.g., -42) to 8-bit two's complement: convert 42 to binary (00101010), flip all bits (11010101), add 1 (11010110).",
                reverseConversion: "To convert two's complement binary back to denary: if MSB is 1, flip bits and add 1 to get magnitude, then apply negative sign.",
                range: "In 8 bits, maximum positive number is 127; maximum negative number is -128.",
                tags: [
                    "Information Representation"
                ]
            },
            {
                term: "Hexadecimal System (Base 16)",
                definition: "Number system with digits 0-9 and letters A-F representing values 10-15.",
                applications: "Used in MAC addresses, HTML colour codes, assembly language, machine code, and debugging memory dumps.",
                examples: "A5 in denary = (10×16) + 5 = 165; 65 in hex = 41 (4×16 + 1).",
                tags: [
                    "Information Representation"
                ]
            },
            {
                term: "Character Sets",
                definition: "Collections of characters (letters, digits, punctuation, symbols) represented by unique binary codes via character encoding.",
                standards: "ASCII (7-bit, 128 characters, English alphabet), Extended ASCII (8-bit, 256 characters, includes European alphabets), Unicode (16-bit or 32-bit, supports multiple languages and a wide range of characters).",
                tradeoff: "ASCII uses less storage but supports fewer characters; Unicode supports many languages but uses more storage.",
                similarities: "All can use 8 bits; ASCII is a subset of Unicode and Extended ASCII.",
                tags: [
                    "Information Representation"
                ]
            },
            {
                term: "ASCII Code",
                definition: "Character encoding standard for electronic communication in English, using 7 or 8 bits.",
                details: "ASCII stands for American Standard Code for Information Interchange. Each character has a unique code stored in the same order as the text.",
                tags: [
                    "Information Representation"
                ]
            },
            {
                term: "Unicode",
                definition: "Character encoding standard supporting a wide range of characters and symbols from multiple languages, typically 16 or 32 bits long.",
                details: "Unicode provides a unique code point for every character regardless of platform, program, or language.",
                tags: [
                    "Information Representation"
                ]
            },
            {
                term: "Bitmap Graphics",
                definition: "Images made up of pixels, each assigned a single colour represented by a unique binary value.",
                encoding: "Stored as a sequence of binary numbers representing each pixel's colour.",
                properties: "Prone to pixelation when enlarged; larger file size due to storing data for each pixel; can be compressed significantly; editing is more difficult as each pixel must be edited separately.",
                fileHeader: "Contains metadata such as file type, compression type, dimensions (width × height), colour depth, image resolution, and file size.",
                tags: [
                    "Multimedia"
                ]
            },
            {
                term: "Pixel",
                definition: "The smallest addressable element in an image or display.",
                details: "Each pixel represents a single point in the image and has a colour value stored in binary.",
                tags: [
                    "Multimedia"
                ]
            },
            {
                term: "Image Resolution",
                definition: "Total number of pixels in an image.",
                formula: "Number of pixels = width × height",
                example: "An image with 4096 × 3192 pixels.",
                effect: "Higher resolution results in sharper, more detailed images with less pixelation.",
                tags: [
                    "Multimedia"
                ]
            },
            {
                term: "Screen Resolution",
                definition: "Number of pixels viewable horizontally and vertically on a device's screen.",
                formula: "Number of pixels = width × height",
                example: "1680 × 1080 pixels.",
                tags: [
                    "Multimedia"
                ]
            },
            {
                term: "Colour Depth (Bit Depth)",
                definition: "Number of bits used to represent the colour of a single pixel.",
                formula: "An image with n bits per pixel can represent 2^n colours.",
                example: "A 16-colour bitmap uses 4 bits per pixel because 2^4 = 16.",
                effect: "Increasing colour depth increases the range of colours and image quality but also increases file size.",
                fileSize: "File size = Number of pixels × Colour depth (bits) / 8 (to convert bits to bytes).",
                tags: [
                    "Multimedia"
                ]
            },
            {
                term: "Vector Graphics",
                definition: "Images composed of mathematically defined drawing objects such as lines, shapes, and curves.",
                encoding: "Stored as a list of drawing commands and properties (drawing list) that define how to draw each object.",
                properties: "Drawing objects have properties defining aspects of appearance (e.g., colour, line thickness).",
                scalability: "Can be resized or scaled without loss of quality or pixelation.",
                fileSize: "Typically smaller file size as only instructions are stored, but do not compress well due to little redundant data.",
                applications: "Used for logos, fonts, and graphics requiring frequent resizing or editing.",
                tags: [
                    "Multimedia"
                ]
            },
            {
                term: "Drawing Object (Vector Graphic)",
                definition: "A component of a vector graphic created using a formula or command.",
                details: "Examples include rectangles, circles, lines, and curves defined by coordinates and properties.",
                tags: [
                    "Multimedia"
                ]
            },
            {
                term: "Drawing Property (Vector Graphic)",
                definition: "Data about the shape defining aspects of its appearance such as colour, line thickness, or font size.",
                example: "A circle may have properties like radius, fill colour, border colour, and border thickness.",
                tags: [
                    "Multimedia"
                ]
            },
            {
                term: "Drawing List (Vector Graphic)",
                definition: "The list of all drawing objects and commands required to recreate the image.",
                example: "Square : line colour : black : fill colour : white : x1 : 10 : y1 : 10 : x2 : 50 : y2 : 50",
                tags: [
                    "Multimedia"
                ]
            },
            {
                term: "Sound Representation",
                definition: "Sound is vibration through a medium and is inherently analogue; to store digitally, amplitude is sampled at regular intervals and each sample is encoded as a binary number.",
                analogueVsDigital: "Analogue data is continuous and variable; digital data is discrete and quantised.",
                tags: [
                    "Multimedia"
                ]
            },
            {
                term: "Sampling",
                definition: "Taking measurements of the amplitude of an analogue sound wave at regular intervals and storing these values.",
                tags: [
                    "Multimedia"
                ]
            },
            {
                term: "Sampling Rate",
                definition: "Number of samples taken per second, measured in Hertz (Hz).",
                effect: "Higher sampling rate reduces gaps between samples, reduces quantisation errors, improves accuracy of digital waveform resembling the analogue wave, but increases file size.",
                tags: [
                    "Multimedia"
                ]
            },
            {
                term: "Sampling Resolution (Bit Depth)",
                definition: "Number of bits used to store each sample of sound.",
                effect: "Higher sampling resolution allows a wider range of amplitudes to be represented, improves accuracy, reduces quantisation errors, but increases file size.",
                tags: [
                    "Multimedia"
                ]
            },
            {
                term: "Bit Rate (Sound)",
                definition: "Number of bits used to store one second of sound.",
                formula: "Bit Rate = Sampling Rate × Sampling Resolution",
                tags: [
                    "Multimedia"
                ]
            },
            {
                term: "Compression",
                definition: "Process of reducing file size to save storage space and reduce transmission time.",
                benefits: "Reduces file size, faster download/upload, less bandwidth usage, allows sending large files via email or web.",
                tags: [
                    "Files"
                ]
            },
            {
                term: "Lossy Compression",
                definition: "Compression method that irreversibly removes some data, resulting in loss of quality.",
                effect: "File size is significantly reduced (often to about 10% of original), but original data cannot be fully restored.",
                applications: "Used when some quality loss is acceptable, e.g., images (JPEG), sound files (MP3), videos.",
                tags: [
                    "Files"
                ]
            },
            {
                term: "Lossless Compression",
                definition: "Compression method that preserves all original data, allowing perfect reconstruction.",
                applications: "Used when all data is needed, e.g., text files, database records, high-quality images (PNG), bitmap and vector graphics.",
                methods: "Includes Run-Length Encoding (RLE) which encodes sequences of identical elements as a single value and count.",
                tags: [
                    "Files"
                ]
            },
            {
                term: "Run-Length Encoding (RLE)",
                definition: "A lossless compression technique that replaces consecutive repeated characters or pixels with a single value and a count.",
                example: "The sequence AAAABBBCCDAA is encoded as 4A 3B 2C 1D 2A.",
                limitations: "Ineffective if data has few repeated sequences; can increase file size if many single occurrences.",
                tags: [
                    "Files"
                ]
            },
            {
                term: "File Header",
                definition: "Metadata at the beginning of a file describing its format and content.",
                details: "Includes file type, compression type, image dimensions, colour depth, resolution, and file size.",
                tags: [
                    "Files"
                ]
            },
            {
                term: "File Size Calculation (Images)",
                definition: "Calculates the file size of an image based on its dimensions and colour depth.",
                formula: "File size (bytes) = Width × Height × Colour Depth (bits) / 8",
                tags: [
                    "Files"
                ]
            },
            {
                term: "File Size Calculation (Sound)",
                definition: "Calculates the file size of a sound file based on duration, sample rate, bit depth, and number of channels.",
                formula: "File size (bytes) = Duration (seconds) × Sample Rate (Hz) × Bit Depth (bits) × Number of Channels / 8 (Bytes)",
                tags: [
                    "Files"
                ]
            },
            {
                term: "Logical Shift",
                definition: "Shifts all bits in a binary number left or right, filling vacated bits with zeros.",
                details: "Does not preserve the sign bit; suitable for unsigned binary numbers.",
                tags: [
                    "Information Representation"
                ]
            },
            {
                term: "Arithmetic Shift",
                definition: "Shifts all bits in a binary number left or right, preserving the sign bit (MSB).",
                details: "Used with signed binary numbers in two's complement representation to maintain sign.",
                tags: [
                    "Information Representation"
                ]
            },
            {
                term: "BCD Conversion",
                definition: "Converts denary numbers to Binary-Coded Decimal by converting each digit separately to its 4-bit binary equivalent.",
                example: "Decimal 45 is represented in BCD as 0100 0101. The plus 6 rule is applied if a nibble exceeds 1001 (9 in decimal) and the carry is counted in the next higher nibble.",
                tags: [
                    "Information Representation"
                ]
            },
            {
                term: "Sample Rate",
                definition: "The number of samples of audio carried per second, measured in Hz.",
                example: "A sample rate of 44.1 kHz means 44,100 samples are taken per second.",
                tags: [
                    "Files"
                ]
            },
            {
                term: "Unit conversions (File Size)",
                definition: "Converts file sizes between different units (e.g., bytes, kilobytes, megabytes).",
                details: " 1Bit x 4 = 1Nibble, 1Bit x 8 = 1Byte(B), 1B x 1000 = 1KB(Kilobyte), 1KB x 1000 = 1MB(Megabyte), 1MB x 1000 = 1GB(Gigabyte), 1GB x 1000 = 1TB(Terabyte). ALSO 1B x 1024 = 1KiB(Kibibyte), 1KiB x 1024 = 1MiB(Mebibyte), 1MiB x 1024 = 1GiB(Gibibyte), 1GiB x 1024 = 1TiB(Trebibyte).",
                example: "1 MB = 1000 KB = 1,000,000 bytes.",
                tags: [
                    "Files"
                ]
            }
        ];

        // Initialize variables
        let currentCardIndex = 0;
        let currentMCIndex = 0;
        let currentTextIndex = 0;
        let selectedTopic = "all";
        
        // Track known and unknown cards
        let knownCards = new Set();
        let unknownCards = [];
        let isReviewingUnknown = false;
        let reviewIndex = 0;

        // Track matching selections
        let selectedTerm = null;
        let selectedDefinition = null;
        let matches = {};
        
        // Track current matching set
        let currentMatchingSet = [];
        let currentMCSet = [];

        // DOM elements
        const topicButtons = document.querySelectorAll('.topic-btn');
        const tabButtons = document.querySelectorAll('.tab-btn');
        const contentSections = document.querySelectorAll('.content-section');
        const flashcard = document.querySelector('.flashcard');
        const currentTerm = document.getElementById('current-term');
        const currentDefinition = document.getElementById('current-definition');
        const currentFormula = document.getElementById('current-formula');
        const currentExample = document.getElementById('current-example');
        const prevCardButton = document.getElementById('prev-card');
        const nextCardButton = document.getElementById('next-card');
        const knowButton = document.getElementById('know-btn');
        const dontKnowButton = document.getElementById('dont-know-btn');
        const cardCounter = document.getElementById('card-counter');
        const progressFill = document.getElementById('progress-fill');
        const sessionStats = document.getElementById('session-stats');
        
        const mcQuestion = document.getElementById('mc-question');
        const mcOptions = document.getElementById('mc-options');
        const checkMCButton = document.getElementById('check-mc');
        const mcResult = document.getElementById('mc-result');
        const prevMCButton = document.getElementById('prev-mc');
        const nextMCButton = document.getElementById('next-mc');
        
        const termsColumn = document.getElementById('terms-column');
        const definitionsColumn = document.getElementById('definitions-column');
        const checkMatchingButton = document.getElementById('check-matching');
        const matchingResult = document.getElementById('matching-result');
        const newMatchingSetButton = document.getElementById('new-matching-set');
        
        const textQuestion = document.getElementById('text-question');
        const textAnswer = document.getElementById('text-answer');
        const checkTextButton = document.getElementById('check-text');
        const textResult = document.getElementById('text-result');
        const correctAnswer = document.getElementById('correct-answer');
        const prevTextButton = document.getElementById('prev-text');
        const nextTextButton = document.getElementById('next-text');
        
        const revisionContent = document.getElementById('revision-content');

        // Filter study data based on selected topic
        function getFilteredStudyData() {
            if (selectedTopic === "all") {
                return studyData;
            }
            return studyData.filter(item => item.tags.includes(selectedTopic));
        }

        // Utility function to shuffle array (Fisher-Yates algorithm)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Generate a random matching set
        function generateMatchingSet() {
            const filteredData = getFilteredStudyData();
            if (filteredData.length < 3) {
                termsColumn.innerHTML = '<p>Not enough items for matching with current filter</p>';
                definitionsColumn.innerHTML = '';
                return;
            }
            
            // Reset matches
            matches = {};
            selectedTerm = null;
            selectedDefinition = null;
            matchingResult.style.display = 'none';
            
            // Clear columns
            termsColumn.innerHTML = '';
            definitionsColumn.innerHTML = '';
            
            // Create a copy of filtered data and shuffle it
            const shuffledData = shuffleArray([...filteredData]);
            
            // Take first 5 items for matching (or fewer if not enough)
            const itemCount = Math.min(5, filteredData.length);
            currentMatchingSet = shuffledData.slice(0, itemCount);
            
            // Create term elements
            currentMatchingSet.forEach((item, index) => {
                const termElement = document.createElement('div');
                termElement.classList.add('match-item');
                termElement.textContent = item.term;
                termElement.setAttribute('data-id', index);
                termsColumn.appendChild(termElement);
            });
            
            // Create definition elements and shuffle them
            const shuffledDefinitions = shuffleArray([...currentMatchingSet]);
            shuffledDefinitions.forEach((item, index) => {
                const definitionElement = document.createElement('div');
                definitionElement.classList.add('match-item');
                definitionElement.textContent = item.definition;
                definitionElement.setAttribute('data-id', currentMatchingSet.indexOf(item));
                definitionsColumn.appendChild(definitionElement);
            });
            
            // Setup event listeners for the new items
            setupMatching();
        }

        // Generate a random multiple choice question
        function generateMCQuestion() {
            const filteredData = getFilteredStudyData();
            if (filteredData.length === 0) {
                mcQuestion.textContent = "No questions available with current filter";
                mcOptions.innerHTML = '';
                return;
            }
            
            // Clear previous options
            mcOptions.innerHTML = '';
            mcResult.style.display = 'none';
            
            // Select a random term from filtered data
            const randomIndex = Math.floor(Math.random() * filteredData.length);
            const correctItem = filteredData[randomIndex];
            
            // Set the question
            mcQuestion.textContent = `What is the definition of "${correctItem.term}"?`;
            
            // Create the correct option
            const correctOption = document.createElement('div');
            correctOption.classList.add('option');
            correctOption.textContent = correctItem.definition;
            correctOption.setAttribute('data-correct', 'true');
            
            // Create incorrect options from other terms
            const incorrectOptions = [];
            const usedIndices = new Set([randomIndex]);
            
            while (incorrectOptions.length < 3 && usedIndices.size < filteredData.length) {
                const randomIdx = Math.floor(Math.random() * filteredData.length);
                if (!usedIndices.has(randomIdx)) {
                    incorrectOptions.push(filteredData[randomIdx].definition);
                    usedIndices.add(randomIdx);
                }
            }
            
            // If we don't have enough incorrect options, add some generic ones
            while (incorrectOptions.length < 3) {
                incorrectOptions.push("No information available");
            }
            
            // Combine and shuffle options
            const allOptions = [correctItem.definition, ...incorrectOptions];
            const shuffledOptions = shuffleArray(allOptions);
            
            // Add options to the DOM
            shuffledOptions.forEach(option => {
                const optionElement = document.createElement('div');
                optionElement.classList.add('option');
                optionElement.textContent = option;
                optionElement.setAttribute('data-correct', option === correctItem.definition ? 'true' : 'false');
                
                optionElement.addEventListener('click', () => {
                    document.querySelectorAll('.option').forEach(opt => opt.classList.remove('selected'));
                    optionElement.classList.add('selected');
                });
                
                mcOptions.appendChild(optionElement);
            });
        }

        // Topic filtering functionality
        topicButtons.forEach(button => {
            button.addEventListener('click', () => {
                const topic = button.getAttribute('data-topic');
                
                // Update active topic button
                topicButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                
                // Set selected topic
                selectedTopic = topic;
                
                // Reset study progress for new filtered set
                currentCardIndex = 0;
                knownCards.clear();
                unknownCards = [];
                isReviewingUnknown = false;
                reviewIndex = 0;
                
                // Update all study sections with filtered data
                updateFlashcard();
                generateMatchingSet();
                generateMCQuestion();
                updateTextQuestion();
                
                // If revision tab is active, regenerate content
                if (document.getElementById('revision').classList.contains('active')) {
                    generateRevisionContent();
                }
            });
        });

        // Tab switching functionality
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const tabId = button.getAttribute('data-tab');
                
                // Update active tab button
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                
                // Show active content section
                contentSections.forEach(section => section.classList.remove('active'));
                document.getElementById(tabId).classList.add('active');
                
                // If matching tab is selected, generate new matching set
                if (tabId === 'matching') {
                    generateMatchingSet();
                }
                
                // If multiple choice tab is selected, generate new question
                if (tabId === 'multiple-choice') {
                    generateMCQuestion();
                }
                
                // If revision tab is selected, generate revision content
                if (tabId === 'revision') {
                    generateRevisionContent();
                }
            });
        });

        // Flashcard functionality
        function updateFlashcard() {
            const filteredData = getFilteredStudyData();
            if (filteredData.length === 0) {
                currentTerm.textContent = "No flashcards available with current filter";
                currentDefinition.textContent = "Try selecting a different topic";
                cardCounter.textContent = `Card 0 of 0`;
                progressFill.style.width = `0%`;
                sessionStats.textContent = `Known: 0/0 | To Review: 0`;
                return;
            }
            
            let index;
            if (isReviewingUnknown) {
                index = unknownCards[reviewIndex];
            } else {
                index = currentCardIndex;
            }
            
            const currentData = filteredData[index];
            currentTerm.textContent = currentData.term;
            
            let definitionHTML = currentData.definition;
            if (currentData.encoding) definitionHTML += `<br><br><strong>Encoding:</strong> ${currentData.encoding}`;
            if (currentData.pixels) definitionHTML += `<br><br><strong>Pixels:</strong> ${currentData.pixels}`;
            if (currentData.fileHeader) definitionHTML += `<br><br><strong>File Header:</strong> ${currentData.fileHeader}`;
            if (currentData.effect) definitionHTML += `<br><br><strong>Effect:</strong> ${currentData.effect}`;
            if (currentData.applications) definitionHTML += `<br><br><strong>Applications:</strong> ${currentData.applications}`;
            
            currentDefinition.innerHTML = definitionHTML;
            
            if (currentData.formula) {
                currentFormula.textContent = `Formula: ${currentData.formula}`;
                currentFormula.style.display = 'block';
            } else {
                currentFormula.style.display = 'none';
            }
            
            if (currentData.example) {
                currentExample.textContent = `Example: ${currentData.example}`;
                currentExample.style.display = 'block';
            } else {
                currentExample.style.display = 'none';
            }
            
            // Update progress counter
            if (isReviewingUnknown) {
                cardCounter.textContent = `Review Card ${reviewIndex + 1} of ${unknownCards.length}`;
            } else {
                cardCounter.textContent = `Card ${currentCardIndex + 1} of ${filteredData.length}`;
            }
            
            // Update progress bar
            const progressPercentage = (knownCards.size / filteredData.length) * 100;
            progressFill.style.width = `${progressPercentage}%`;
            
            // Update session stats
            sessionStats.textContent = `Known: ${knownCards.size}/${filteredData.length} | To Review: ${unknownCards.length}`;
        }

        flashcard.addEventListener('click', () => {
            flashcard.classList.toggle('flipped');
        });

        // Handle "I Know This" button
        knowButton.addEventListener('click', () => {
            const filteredData = getFilteredStudyData();
            if (filteredData.length === 0) return;
            
            let index;
            if (isReviewingUnknown) {
                index = unknownCards[reviewIndex];
                // Remove from unknown cards
                unknownCards.splice(reviewIndex, 1);
                // Add to known cards
                knownCards.add(index);
                
                // If no more unknown cards, switch back to normal mode
                if (unknownCards.length === 0) {
                    isReviewingUnknown = false;
                    reviewIndex = 0;
                    currentCardIndex = (currentCardIndex + 1) % filteredData.length;
                } else {
                    // Stay in review mode but move to next card
                    reviewIndex = reviewIndex % unknownCards.length;
                }
            } else {
                index = currentCardIndex;
                knownCards.add(index);
                // Remove from unknown if it was there
                const unknownIndex = unknownCards.indexOf(index);
                if (unknownIndex !== -1) {
                    unknownCards.splice(unknownIndex, 1);
                }
                currentCardIndex = (currentCardIndex + 1) % filteredData.length;
                
                // If we've completed all cards and there are unknown ones, start reviewing
                if (currentCardIndex === 0 && unknownCards.length > 0) {
                    isReviewingUnknown = true;
                    reviewIndex = 0;
                }
            }
            
            flashcard.classList.remove('flipped');
            updateFlashcard();
        });

        // Handle "I Don't Know" button
        dontKnowButton.addEventListener('click', () => {
            const filteredData = getFilteredStudyData();
            if (filteredData.length === 0) return;
            
            let index;
            if (isReviewingUnknown) {
                index = unknownCards[reviewIndex];
                // Move to next card in review
                reviewIndex = (reviewIndex + 1) % unknownCards.length;
            } else {
                index = currentCardIndex;
                // Add to unknown cards if not already there
                if (!unknownCards.includes(index)) {
                    unknownCards.push(index);
                }
                // Remove from known cards if it was there
                if (knownCards.has(index)) {
                    knownCards.delete(index);
                }
                currentCardIndex = (currentCardIndex + 1) % filteredData.length;
                
                // If we've completed all cards, start reviewing unknown ones
                if (currentCardIndex === 0 && unknownCards.length > 0) {
                    isReviewingUnknown = true;
                    reviewIndex = 0;
                }
            }
            
            flashcard.classList.remove('flipped');
            updateFlashcard();
        });

        prevCardButton.addEventListener('click', () => {
            const filteredData = getFilteredStudyData();
            if (filteredData.length === 0) return;
            
            if (isReviewingUnknown) {
                reviewIndex = (reviewIndex - 1 + unknownCards.length) % unknownCards.length;
            } else {
                currentCardIndex = (currentCardIndex - 1 + filteredData.length) % filteredData.length;
            }
            flashcard.classList.remove('flipped');
            updateFlashcard();
        });

        nextCardButton.addEventListener('click', () => {
            const filteredData = getFilteredStudyData();
            if (filteredData.length === 0) return;
            
            if (isReviewingUnknown) {
                reviewIndex = (reviewIndex + 1) % unknownCards.length;
            } else {
                currentCardIndex = (currentCardIndex + 1) % filteredData.length;
            }
            flashcard.classList.remove('flipped');
            updateFlashcard();
        });

        // Multiple choice functionality
        checkMCButton.addEventListener('click', () => {
            const selectedOption = document.querySelector('.option.selected');
            if (!selectedOption) {
                mcResult.textContent = 'Please select an answer.';
                mcResult.className = 'result incorrect';
                mcResult.style.display = 'block';
                return;
            }
            
            const isCorrect = selectedOption.getAttribute('data-correct') === 'true';
            if (isCorrect) {
                mcResult.textContent = 'Correct! Well done.';
                mcResult.className = 'result correct';
            } else {
                mcResult.textContent = 'Incorrect. Try again.';
                mcResult.className = 'result incorrect';
            }
            mcResult.style.display = 'block';
        });

        prevMCButton.addEventListener('click', () => {
            generateMCQuestion();
        });

        nextMCButton.addEventListener('click', () => {
            generateMCQuestion();
        });

        // Matching functionality
        function setupMatching() {
            const matchItems = document.querySelectorAll('.match-item');
            
            matchItems.forEach(item => {
                item.addEventListener('click', () => {
                    // Check if item is in the terms column
                    if (item.parentElement.id === 'terms-column') {
                        // Deselect all other terms
                        document.querySelectorAll('#terms-column .match-item').forEach(term => {
                            term.classList.remove('selected');
                        });
                        
                        // Select this term
                        item.classList.add('selected');
                        selectedTerm = item;
                    } 
                    // Check if item is in the definitions column
                    else if (item.parentElement.id === 'definitions-column') {
                        // Deselect all other definitions
                        document.querySelectorAll('#definitions-column .match-item').forEach(def => {
                            def.classList.remove('selected');
                        });
                        
                        // Select this definition
                        item.classList.add('selected');
                        selectedDefinition = item;
                    }
                    
                    // If both a term and a definition are selected, check if they match
                    if (selectedTerm && selectedDefinition) {
                        const termId = selectedTerm.getAttribute('data-id');
                        const definitionId = selectedDefinition.getAttribute('data-id');
                        
                        if (termId === definitionId) {
                            // Correct match
                            selectedTerm.style.background = 'var(--success)';
                            selectedDefinition.style.background = 'var(--success)';
                            selectedTerm.classList.remove('selected');
                            selectedDefinition.classList.remove('selected');
                            
                            // Store the match
                            matches[termId] = true;
                            
                            // Reset selections
                            selectedTerm = null;
                            selectedDefinition = null;
                            
                            // Check if all matches are complete
                            if (Object.keys(matches).length === currentMatchingSet.length) {
                                matchingResult.textContent = 'All matches are correct! Well done.';
                                matchingResult.className = 'result correct';
                                matchingResult.style.display = 'block';
                            }
                        } else {
                            // Incorrect match - flash red and then reset
                            selectedTerm.style.background = 'var(--error)';
                            selectedDefinition.style.background = 'var(--error)';
                            
                            setTimeout(() => {
                                selectedTerm.style.background = '';
                                selectedDefinition.style.background = '';
                                selectedTerm.classList.remove('selected');
                                selectedDefinition.classList.remove('selected');
                                selectedTerm = null;
                                selectedDefinition = null;
                            }, 1000);
                        }
                    }
                });
            });
        }

        checkMatchingButton.addEventListener('click', () => {
            // Check if all matches are correct
            const allMatched = Object.keys(matches).length === currentMatchingSet.length;
            
            if (allMatched) {
                matchingResult.textContent = 'All matches are correct! Well done.';
                matchingResult.className = 'result correct';
            } else {
                matchingResult.textContent = 'Some matches are incorrect. Keep trying!';
                matchingResult.className = 'result incorrect';
            }
            matchingResult.style.display = 'block';
        });

        // Text input functionality
        function updateTextQuestion() {
            const filteredData = getFilteredStudyData();
            if (filteredData.length === 0) {
                textQuestion.textContent = "No questions available with current filter";
                return;
            }
            
            const currentText = filteredData[currentTextIndex];
            textQuestion.textContent = `What is the definition of "${currentText.term}"?`;
            textAnswer.value = '';
            textResult.style.display = 'none';
            correctAnswer.style.display = 'none';
        }

        checkTextButton.addEventListener('click', () => {
            const filteredData = getFilteredStudyData();
            if (filteredData.length === 0) return;
            
            const userAnswer = textAnswer.value.trim().toLowerCase();
            const correctAns = filteredData[currentTextIndex].definition.toLowerCase();
            
            // Simple check - in a real app you might use more advanced string similarity
            if (userAnswer === correctAns) {
                textResult.textContent = 'Correct! Well done.';
                textResult.className = 'result correct';
                correctAnswer.style.display = 'none';
            } else {
                textResult.textContent = 'Not quite right. The correct answer is:';
                textResult.className = 'result incorrect';
                correctAnswer.textContent = filteredData[currentTextIndex].definition;
                correctAnswer.style.display = 'block';
            }
            textResult.style.display = 'block';
        });

        prevTextButton.addEventListener('click', () => {
            const filteredData = getFilteredStudyData();
            if (filteredData.length === 0) return;
            
            currentTextIndex = (currentTextIndex - 1 + filteredData.length) % filteredData.length;
            updateTextQuestion();
        });

        nextTextButton.addEventListener('click', () => {
            const filteredData = getFilteredStudyData();
            if (filteredData.length === 0) return;
            
            currentTextIndex = (currentTextIndex + 1) % filteredData.length;
            updateTextQuestion();
        });

        // Revision content generation - UPDATED TO SHOW ALL DATA
        function generateRevisionContent() {
            revisionContent.innerHTML = '';
            
            const filteredData = getFilteredStudyData();
            if (filteredData.length === 0) {
                revisionContent.innerHTML = '<p>No revision materials available with current filter</p>';
                return;
            }
            
            filteredData.forEach(item => {
                const revisionItem = document.createElement('div');
                revisionItem.classList.add('revision-item');
                
                let contentHTML = `<div class="revision-term">${item.term}`;
                
                // Add tag indicators
                if (item.tags && item.tags.length) {
                    item.tags.forEach(tag => {
                        let tagClass = '';
                        if (tag === 'Information Representation') tagClass = 'tag-info-rep';
                        if (tag === 'Multimedia') tagClass = 'tag-multimedia';
                        if (tag === 'Files') tagClass = 'tag-files';
                        
                        contentHTML += `<span class="tag-indicator ${tagClass}">${tag}</span>`;
                    });
                }
                
                contentHTML += `</div>`;
                
                // Add all properties from the study item
                const propertiesToShow = [
                    'definition', 'details', 'example', 'applications', 'benefits',
                    'conversion', 'reverseConversion', 'range', 'standards', 'tradeoff',
                    'similarities', 'encoding', 'properties', 'effect', 'formula',
                    'fileHeader', 'drawingList', 'scalability', 'pixels', 'analogueVsDigital',
                    'fileSize', 'limitations', 'methods'
                ];
                
                propertiesToShow.forEach(prop => {
                    if (item[prop]) {
                        // Format property name for display
                        const displayName = prop.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                        contentHTML += `
                            <div class="revision-property">
                                <div class="revision-property-title">${displayName}:</div>
                                <div>${item[prop]}</div>
                            </div>
                        `;
                    }
                });
                
                revisionItem.innerHTML = contentHTML;
                revisionContent.appendChild(revisionItem);
            });
        }

        // Initialize the application
        updateFlashcard();
        updateTextQuestion();
        generateMatchingSet(); // Initialize matching functionality
        generateMCQuestion(); // Initialize multiple choice questions
        
        // Event listener for new matching set button
        newMatchingSetButton.addEventListener('click', generateMatchingSet);
    </script>
</body>
</html>
