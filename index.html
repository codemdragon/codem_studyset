<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Codem's Study Hub</title>
    <style>
        :root {
            --primary-bg: #0a0a14;
            --secondary-bg: #12122a;
            --card-bg: #1a1a3a;
            --accent-blue: #00aaff;
            --accent-blue-dark: #0088cc;
            --text-primary: #ffffff;
            --text-secondary: #ccccff;
            --success: #00cc88;
            --error: #ff3366;
            --info-rep: #ff9966;
            --multimedia: #9966cc;
            --files: #66cc99;
            --form-color: #ffcc66;
            --processor: #ff6699;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, var(--primary-bg), var(--secondary-bg));
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0, 170, 255, 0.2);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(to right, var(--accent-blue), #00ddff);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 10px rgba(0, 170, 255, 0.5);
        }
        
        .topic-filter {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .topic-btn {
            background: var(--card-bg);
            color: var(--text-secondary);
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            font-size: 0.9rem;
        }
        
        .topic-btn:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }
        
        .topic-btn.active {
            box-shadow: 0 0 10px currentColor;
        }
        
        .topic-btn.info-rep {
            background-color: var(--info-rep);
            color: var(--primary-bg);
        }
        
        .topic-btn.multimedia {
            background-color: var(--multimedia);
            color: var(--primary-bg);
        }
        
        .topic-btn.files {
            background-color: var(--files);
            color: var(--primary-bg);
        }
        
        .topic-btn.processor {
            background-color: var(--processor);
            color: var(--primary-bg);
        }
        
        .topic-btn.form {
            background-color: var(--form-color);
            color: var(--primary-bg);
        }
        
        .topic-btn.all {
            background: var(--accent-blue);
            color: var(--primary-bg);
        }
        
        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .tab-btn {
            background: var(--card-bg);
            color: var(--text-secondary);
            border: none;
            padding: 12px 24px;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }
        
        .tab-btn:hover {
            background: rgba(0, 170, 255, 0.2);
            transform: translateY(-2px);
        }
        
        .tab-btn.active {
            background: var(--accent-blue);
            color: var(--primary-bg);
            box-shadow: 0 0 15px var(--accent-blue);
        }
        
        .tab-btn.form {
            background: var(--card-bg);
            color: var(--text-secondary);
        }
        
        .tab-btn.form.active {
            background: var(--form-color);
            color: var(--primary-bg);
            box-shadow: 0 0 15px var(--form-color);
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        
        .content-section {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            display: none;
            max-height: calc(100vh - 250px);
            overflow-y: auto;
        }
        
        .content-section.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        h2 {
            color: var(--accent-blue);
            margin-bottom: 20px;
            font-size: 1.8rem;
        }
        
        .flashcard {
            perspective: 1000px;
            height: 250px;
            margin: 20px 0;
            cursor: pointer;
        }
        
        .flashcard-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }
        
        .flashcard.flipped .flashcard-inner {
            transform: rotateY(180deg);
        }
        
        .flashcard-front, .flashcard-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            border-radius: 15px;
            background: linear-gradient(145deg, #1f1f4a, #25255a);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
        }
        
        .flashcard-back {
            transform: rotateY(180deg);
            text-align: left;
            justify-content: flex-start;
        }
        
        .term {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--accent-blue);
        }
        
        .definition {
            font-size: 1.2rem;
            color: var(--text-primary);
        }
        
        .formula {
            background: rgba(0, 170, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 1.1rem;
        }
        
        .example {
            color: var(--text-secondary);
            font-style: italic;
            margin-top: 10px;
        }
        
        .nav-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        
        button {
            background: var(--accent-blue);
            color: var(--primary-bg);
            border: none;
            padding: 12px 20px;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }
        
        button:hover {
            background: var(--accent-blue-dark);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 170, 255, 0.4);
        }
        
        .question {
            background: linear-gradient(145deg, #1f1f4a, #25255a);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
        }
        
        .options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }
        
        .option {
            background: var(--secondary-bg);
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .option:hover {
            background: rgba(0, 170, 255, 0.2);
        }
        
        .option.selected {
            background: var(--accent-blue);
            color: var(--primary-bg);
        }
        
        .matching-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .match-item {
            background: linear-gradient(145deg, #1f1f4a, #25255a);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .match-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 170, 255, 0.3);
        }
        
        .match-item.selected {
            opacity: 0.6;
            background: rgba(0, 170, 255, 0.2);
            border: 2px solid var(--accent-blue);
        }
        
        .text-input {
            width: 100%;
            background: var(--secondary-bg);
            border: 2px solid var(--accent-blue);
            border-radius: 10px;
            padding: 15px;
            color: var(--text-primary);
            font-size: 1.1rem;
            margin-bottom: 15px;
        }
        
        .result {
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            display: none;
        }
        
        .correct {
            background: rgba(0, 204, 136, 0.2);
            border: 2px solid var(--success);
        }
        
        .incorrect {
            background: rgba(255, 51, 102, 0.2);
            border: 2px solid var(--error);
        }
        
        .revision-item {
            background: linear-gradient(145deg, #1f1f4a, #25255a);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
        }
        
        .revision-term {
            color: var(--accent-blue);
            font-size: 1.5rem;
            margin-bottom: 10px;
        }

        .progress-info {
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.1rem;
            color: var(--text-secondary);
        }

        .knowledge-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }

        .btn-know {
            background: var(--success);
        }

        .btn-dont-know {
            background: var(--error);
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: var(--secondary-bg);
            border-radius: 5px;
            margin: 15px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--success);
            width: 0%;
            transition: width 0.3s ease;
        }

        .session-stats {
            text-align: center;
            margin-top: 15px;
            color: var(--text-secondary);
        }
        
        .tag-indicator {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            margin-left: 8px;
            vertical-align: middle;
        }
        
        .tag-info-rep {
            background-color: var(--info-rep);
            color: var(--primary-bg);
        }
        
        .tag-multimedia {
            background-color: var(--multimedia);
            color: var(--primary-bg);
        }
        
        .tag-files {
            background-color: var(--files);
            color: var(--primary-bg);
        }
        
        .tag-processor {
            background-color: var(--processor);
            color: var(--primary-bg);
        }
        
        .tag-form {
            background-color: var(--form-color);
            color: var(--primary-bg);
        }

        /* Form Section Styles */
        .form-container {
            width: 100%;
            height: 600px;
            overflow: hidden;
            border-radius: 10px;
            margin-top: 20px;
        }
        
        .form-iframe {
            width: 100%;
            height: 100%;
            border: none;
            background-color: white;
        }
        
        .form-note {
            text-align: center;
            margin-top: 15px;
            color: var(--text-secondary);
            font-style: italic;
        }
        
        /* Revision Section Styles */
        .revision-property {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }
        
        .revision-property-title {
            font-weight: bold;
            color: var(--accent-blue);
            margin-bottom: 5px;
        }

        /* PDF Download Button */
        .pdf-download {
            background: var(--error);
            margin-bottom: 20px;
        }
        
        .pdf-download:hover {
            background: #ff2255;
        }

        @media (max-width: 768px) {
            .options {
                grid-template-columns: 1fr;
            }
            
            .matching-container {
                grid-template-columns: 1fr;
            }

            .knowledge-buttons {
                flex-direction: column;
            }
            
            .flashcard {
                height: 200px;
            }
            
            .term {
                font-size: 1.5rem;
            }
            
            .definition {
                font-size: 1rem;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            h2 {
                font-size: 1.5rem;
            }
            
            .content-section {
                max-height: calc(100vh - 200px);
                padding: 15px;
            }
            
            .topic-btn {
                font-size: 0.8rem;
                padding: 6px 12px;
            }
            
            .form-container {
                height: 500px;
            }
        }

        @media (max-width: 480px) {
            .tabs {
                flex-direction: column;
                align-items: center;
            }
            
            .tab-btn {
                width: 100%;
                margin-bottom: 5px;
            }
            
            .flashcard {
                height: 180px;
            }
            
            .term {
                font-size: 1.3rem;
            }
            
            .nav-buttons {
                flex-direction: column;
                gap: 10px;
            }
            
            .nav-buttons button {
                width: 100%;
            }
            
            header {
                padding: 15px;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            body {
                padding: 10px;
            }
            
            .topic-filter {
                gap: 5px;
            }
            
            .topic-btn {
                font-size: 0.7rem;
                padding: 5px 10px;
            }
            
            .form-container {
                height: 400px;
            }
        }

        /* Orientation-specific adjustments */
        @media (max-height: 600px) and (orientation: landscape) {
            .content-section {
                max-height: calc(100vh - 180px);
            }
            
            .flashcard {
                height: 180px;
            }
            
            header {
                padding: 10px;
                margin-bottom: 15px;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            .form-container {
                height: 350px;
            }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--secondary-bg);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--accent-blue);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-blue-dark);
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
</head>
<body>
    <header>
        <h1>Codem's Study Hub</h1>
        <p>Master Your Classes Easily</p>
    </header>
    
    <div class="container">
        <div class="topic-filter">
            <button class="topic-btn all active" data-topic="all">All Topics</button>
            <button class="topic-btn info-rep" data-topic="Information Representation">Information Representation</button>
            <button class="topic-btn multimedia" data-topic="Multimedia">Multimedia</button>
            <button class="topic-btn files" data-topic="Files">Files</button>
            <button class="topic-btn processor" data-topic="Processor">Processor</button>
            <button class="topic-btn form" data-topic="Form">Contribute to Website</button>
        </div>
        
        <div class="tabs">
            <button class="tab-btn active" data-tab="flashcards">Flashcards</button>
            <button class="tab-btn" data-tab="multiple-choice">Multiple Choice</button>
            <button class="tab-btn" data-tab="matching">Matching</button>
            <button class="tab-btn" data-tab="text-based">Text Input</button>
            <button class="tab-btn" data-tab="revision">Revision</button>
            <button class="tab-btn form" data-tab="quiz-form">Contribute to Website</button>
        </div>
        
        <div id="flashcards" class="content-section active">
            <h2>Flashcards</h2>
            <div class="progress-info">
                <span id="card-counter">Card 1 of 30</span>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div class="flashcard">
                <div class="flashcard-inner">
                    <div class="flashcard-front">
                        <div class="term" id="current-term">Binary Coded Decimal (BCD)</div>
                        <p>Click to flip</p>
                    </div>
                    <div class="flashcard-back">
                        <div class="definition" id="current-definition">Binary representation where each positive denary digit is represented by a sequence of 4 bits (nibble).</div>
                        <div class="formula" id="current-formula"></div>
                        <div class="example" id="current-example"></div>
                    </div>
                </div>
            </div>
            <div class="knowledge-buttons">
                <button class="btn-know" id="know-btn">I Know This</button>
                <button class="btn-dont-know" id="dont-know-btn">I Don't Know</button>
            </div>
            <div class="nav-buttons">
                <button id="prev-card">Previous</button>
                <button id="next-card">Next</button>
            </div>
            <div class="session-stats" id="session-stats">
                Known: 0/30 | To Review: 0
            </div>
        </div>
        
        <div id="multiple-choice" class="content-section">
            <h2>Multiple Choice Questions</h2>
            <div class="question">
                <p id="mc-question">What does BCD stand for?</p>
                <div class="options" id="mc-options">
                    <div class="option" data-correct="true">Binary Coded Decimal</div>
                    <div class="option">Binary Character Decimal</div>
                    <div class="option">Basic Computer Data</div>
                    <div class="option">Binary Code Digit</div>
                </div>
            </div>
            <button id="check-mc">Check Answer</button>
            <div class="result" id="mc-result"></div>
            <div class="nav-buttons">
                <button id="prev-mc">Previous</button>
                <button id="next-mc">Next</button>
            </div>
        </div>
        
        <div id="matching" class="content-section">
            <h2>Matching Exercise</h2>
            <p>Click items from the left column to match with items on the right</p>
            <div class="matching-container">
                <div class="matching-column" id="terms-column">
                    </div>
                <div class="matching-column" id="definitions-column">
                    </div>
            </div>
            <button id="check-matching">Check Answers</button>
            <div class="result" id="matching-result"></div>
            <button id="new-matching-set" style="margin-top: 15px;">New Set</button>
        </div>
        
        <div id="text-based" class="content-section">
            <h2>Text Input Exercise</h2>
            <div class="question">
                <p id="text-question">What does BCD stand for?</p>
                <input type="text" class="text-input" id="text-answer" placeholder="Type your answer here...">
                <button id="check-text">Check Answer</button>
                <div class="result" id="text-result"></div>
                <div class="correct-answer" id="correct-answer"></div>
            </div>
            <div class="nav-buttons">
                <button id="prev-text">Previous</button>
                <button id="next-text">Next</button>
            </div>
        </div>
        
        <div id="revision" class="content-section">
            <h2>Revision Materials</h2>
            <button id="download-pdf" class="pdf-download">Download as PDF</button>
            <div id="revision-content">
                </div>
        </div>
        
        <div id="quiz-form" class="content-section">
            <h2>Contribute to Website <span class="tag-indicator tag-form">External</span></h2>
            <p>Please fill out the form below to contribute to our website.</p>
            
            <div class="form-container">
                <iframe class="form-iframe" src="https://docs.google.com/forms/d/e/1FAIpQLSdxZPupUKB018u68kLJcfN8_CM3Tgn_VB1bW3sAszy9z9Ft9A/viewform?embedded=true" frameborder="0" marginheight="0" marginwidth="0">Loadingâ€¦</iframe>
            </div>
            
            <div class="form-note">
                <p>Note: This form is hosted externally by Google. Your responses will be submitted to the form owner.</p>
            </div>
        </div>
    </div>

    <script>
        // Study data will be loaded from study.json
        let studyData = [];

        // Initialize variables
        let currentCardIndex = 0;
        let currentMCIndex = 0;
        let currentTextIndex = 0;
        let selectedTopic = "all";
        
        // Track known and unknown cards
        let knownCards = new Set();
        let unknownCards = [];
        let isReviewingUnknown = false;
        let reviewIndex = 0;

        // Track matching selections
        let selectedTerm = null;
        let selectedDefinition = null;
        let matches = {};
        
        // Track current matching set
        let currentMatchingSet = [];
        let currentMCSet = [];
        
        // Store the current question objects
        let currentMCQuestionObject = null;
        let currentTextQuestionObject = null;

        // DOM elements
        const topicButtons = document.querySelectorAll('.topic-btn');
        const tabButtons = document.querySelectorAll('.tab-btn');
        const contentSections = document.querySelectorAll('.content-section');
        const flashcard = document.querySelector('.flashcard');
        const currentTerm = document.getElementById('current-term');
        const currentDefinition = document.getElementById('current-definition');
        const currentFormula = document.getElementById('current-formula');
        const currentExample = document.getElementById('current-example');
        const prevCardButton = document.getElementById('prev-card');
        const nextCardButton = document.getElementById('next-card');
        const knowButton = document.getElementById('know-btn');
        const dontKnowButton = document.getElementById('dont-know-btn');
        const cardCounter = document.getElementById('card-counter');
        const progressFill = document.getElementById('progress-fill');
        const sessionStats = document.getElementById('session-stats');
        
        const mcQuestion = document.getElementById('mc-question');
        const mcOptions = document.getElementById('mc-options');
        const checkMCButton = document.getElementById('check-mc');
        const mcResult = document.getElementById('mc-result');
        const prevMCButton = document.getElementById('prev-mc');
        const nextMCButton = document.getElementById('next-mc');
        
        const termsColumn = document.getElementById('terms-column');
        const definitionsColumn = document.getElementById('definitions-column');
        const checkMatchingButton = document.getElementById('check-matching');
        const matchingResult = document.getElementById('matching-result');
        const newMatchingSetButton = document.getElementById('new-matching-set');
        
        const textQuestion = document.getElementById('text-question');
        const textAnswer = document.getElementById('text-answer');
        const checkTextButton = document.getElementById('check-text');
        const textResult = document.getElementById('text-result');
        const correctAnswer = document.getElementById('correct-answer');
        const prevTextButton = document.getElementById('prev-text');
        const nextTextButton = document.getElementById('next-text');
        
        const revisionContent = document.getElementById('revision-content');
        const downloadPdfButton = document.getElementById('download-pdf');

        // Load study data from JSON file
        async function loadStudyData() {
            try {
                const response = await fetch('study.json');
                studyData = await response.json();
                
                // Initialize the application after data is loaded
                updateFlashcard();
                updateMCQuestion();
                updateTextQuestion();
                generateMatchingSet();
            } catch (error) {
                console.error('Error loading study data:', error);
                currentTerm.textContent = "Error loading study data. Please check if study.json exists.";
            }
        }

        // Filter study data based on selected topic
        function getFilteredStudyData() {
            if (selectedTopic === "all") {
                return studyData;
            }
            return studyData.filter(item => item.tags.includes(selectedTopic));
        }

        // Utility function to shuffle array (Fisher-Yates algorithm)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Generate a random matching set
        function generateMatchingSet() {
            const filteredData = getFilteredStudyData();
            if (filteredData.length < 3) {
                termsColumn.innerHTML = '<p>Not enough items for matching with current filter</p>';
                definitionsColumn.innerHTML = '';
                return;
            }
            
            // Reset matches
            matches = {};
            selectedTerm = null;
            selectedDefinition = null;
            matchingResult.style.display = 'none';
            
            // Clear columns
            termsColumn.innerHTML = '';
            definitionsColumn.innerHTML = '';
            
            // Create a copy of filtered data and shuffle it
            const shuffledData = shuffleArray([...filteredData]);
            
            // Take first 5 items for matching (or fewer if not enough)
            const itemCount = Math.min(5, filteredData.length);
            currentMatchingSet = shuffledData.slice(0, itemCount);
            
            // Create term elements
            currentMatchingSet.forEach((item, index) => {
                const termElement = document.createElement('div');
                termElement.classList.add('match-item');
                termElement.textContent = item.term;
                termElement.setAttribute('data-id', index);
                termsColumn.appendChild(termElement);
            });
            
            // Create definition elements and shuffle them
            const shuffledDefinitions = shuffleArray([...currentMatchingSet]);
            shuffledDefinitions.forEach((item, index) => {
                const definitionElement = document.createElement('div');
                definitionElement.classList.add('match-item');
                definitionElement.textContent = item.definition;
                definitionElement.setAttribute('data-id', currentMatchingSet.indexOf(item));
                definitionsColumn.appendChild(definitionElement);
            });
            
            // Setup event listeners for the new items
            setupMatching();
        }

        // Generate a random multiple choice question using the questions array
        function updateMCQuestion() {
            const filteredData = getFilteredStudyData();
            if (filteredData.length === 0) {
                mcQuestion.textContent = "No questions available with current filter";
                mcOptions.innerHTML = '';
                return;
            }
            
            // Clear previous options
            mcOptions.innerHTML = '';
            mcResult.style.display = 'none';
            
            // Select a random term from filtered data
            const randomIndex = Math.floor(Math.random() * filteredData.length);
            const correctItem = filteredData[randomIndex];
            
            // Check if the term has specific questions
            if (correctItem.questions && correctItem.questions.length > 0) {
                // Select a random question object
                currentMCQuestionObject = correctItem.questions[Math.floor(Math.random() * correctItem.questions.length)];
            } else {
                // Fallback to default definition question
                currentMCQuestionObject = {
                    q: `What is the definition of "${correctItem.term}"?`,
                    a: correctItem.definition
                };
            }
            
            // Set the question text from the chosen object
            mcQuestion.textContent = currentMCQuestionObject.q;
            
            // Create the correct option
            const correctOption = document.createElement('div');
            correctOption.classList.add('option');
            correctOption.textContent = currentMCQuestionObject.a;
            correctOption.setAttribute('data-correct', 'true');
            
            // Create incorrect options from other questions
            const incorrectOptions = [];
            const usedAnswers = new Set([currentMCQuestionObject.a]);
            
            // Try to get answers from other questions
            for (let i = 0; i < filteredData.length && incorrectOptions.length < 3; i++) {
                const item = filteredData[i];
                if (item.questions && item.questions.length > 0) {
                    for (let j = 0; j < item.questions.length && incorrectOptions.length < 3; j++) {
                        const answer = item.questions[j].a;
                        if (!usedAnswers.has(answer)) {
                            incorrectOptions.push(answer);
                            usedAnswers.add(answer);
                        }
                    }
                } else if (!usedAnswers.has(item.definition)) {
                    incorrectOptions.push(item.definition);
                    usedAnswers.add(item.definition);
                }
            }
            
            // If we don't have enough incorrect options, add some generic ones
            while (incorrectOptions.length < 3) {
                incorrectOptions.push("No information available");
            }
            
            // Combine and shuffle options
            const allOptions = [currentMCQuestionObject.a, ...incorrectOptions];
            const shuffledOptions = shuffleArray(allOptions);
            
            // Add options to the DOM
            shuffledOptions.forEach(option => {
                const optionElement = document.createElement('div');
                optionElement.classList.add('option');
                optionElement.textContent = option;
                optionElement.setAttribute('data-correct', option === currentMCQuestionObject.a ? 'true' : 'false');
                
                optionElement.addEventListener('click', () => {
                    document.querySelectorAll('.option').forEach(opt => opt.classList.remove('selected'));
                    optionElement.classList.add('selected');
                });
                
                mcOptions.appendChild(optionElement);
            });
        }

        // Topic filtering functionality
        topicButtons.forEach(button => {
            button.addEventListener('click', () => {
                const topic = button.getAttribute('data-topic');
                
                // Update active topic button
                topicButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                
                // Set selected topic
                selectedTopic = topic;
                
                // Reset study progress for new filtered set
                currentCardIndex = 0;
                currentMCIndex = 0;
                currentTextIndex = 0;
                knownCards.clear();
                unknownCards = [];
                isReviewingUnknown = false;
                reviewIndex = 0;
                
                // Update all study sections with filtered data
                updateFlashcard();
                generateMatchingSet();
                updateMCQuestion();
                updateTextQuestion();
                
                // If revision tab is active, regenerate content
                if (document.getElementById('revision').classList.contains('active')) {
                    generateRevisionContent();
                }
            });
        });

        // Tab switching functionality
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const tabId = button.getAttribute('data-tab');
                
                // Update active tab button
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                
                // Show active content section
                contentSections.forEach(section => section.classList.remove('active'));
                document.getElementById(tabId).classList.add('active');
                
                // If matching tab is selected, generate new matching set
                if (tabId === 'matching') {
                    generateMatchingSet();
                }
                
                // If multiple choice tab is selected, generate new question
                if (tabId === 'multiple-choice') {
                    updateMCQuestion();
                }
                
                // If revision tab is selected, generate revision content
                if (tabId === 'revision') {
                    generateRevisionContent();
                }
            });
        });

        // Flashcard functionality
        function updateFlashcard() {
            const filteredData = getFilteredStudyData();
            if (filteredData.length === 0) {
                currentTerm.textContent = "No flashcards available with current filter";
                currentDefinition.textContent = "Try selecting a different topic";
                cardCounter.textContent = `Card 0 of 0`;
                progressFill.style.width = `0%`;
                sessionStats.textContent = `Known: 0/0 | To Review: 0`;
                return;
            }
            
            let index;
            if (isReviewingUnknown) {
                index = unknownCards[reviewIndex];
            } else {
                index = currentCardIndex;
            }
            
            const currentData = filteredData[index];
            currentTerm.textContent = currentData.term;
            
            let definitionHTML = currentData.definition;
            if (currentData.encoding) definitionHTML += `<br><br><strong>Encoding:</strong> ${currentData.encoding}`;
            if (currentData.pixels) definitionHTML += `<br><br><strong>Pixels:</strong> ${currentData.pixels}`;
            if (currentData.fileHeader) definitionHTML += `<br><br><strong>File Header:</strong> ${currentData.fileHeader}`;
            if (currentData.effect) definitionHTML += `<br><br><strong>Effect:</strong> ${currentData.effect}`;
            if (currentData.applications) definitionHTML += `<br><br><strong>Applications:</strong> ${currentData.applications}`;
            
            currentDefinition.innerHTML = definitionHTML;
            
            if (currentData.formula) {
                currentFormula.textContent = `Formula: ${currentData.formula}`;
                currentFormula.style.display = 'block';
            } else {
                currentFormula.style.display = 'none';
            }
            
            if (currentData.example) {
                currentExample.textContent = `Example: ${currentData.example}`;
                currentExample.style.display = 'block';
            } else {
                currentExample.style.display = 'none';
            }
            
            // Update progress counter
            if (isReviewingUnknown) {
                cardCounter.textContent = `Review Card ${reviewIndex + 1} of ${unknownCards.length}`;
            } else {
                cardCounter.textContent = `Card ${currentCardIndex + 1} of ${filteredData.length}`;
            }
            
            // Update progress bar
            const progressPercentage = (knownCards.size / filteredData.length) * 100;
            progressFill.style.width = `${progressPercentage}%`;
            
            // Update session stats
            sessionStats.textContent = `Known: ${knownCards.size}/${filteredData.length} | To Review: ${unknownCards.length}`;
        }

        flashcard.addEventListener('click', () => {
            flashcard.classList.toggle('flipped');
        });

        // Handle "I Know This" button
        knowButton.addEventListener('click', () => {
            const filteredData = getFilteredStudyData();
            if (filteredData.length === 0) return;
            
            let index;
            if (isReviewingUnknown) {
                index = unknownCards[reviewIndex];
                // Remove from unknown cards
                unknownCards.splice(reviewIndex, 1);
                // Add to known cards
                knownCards.add(index);
                
                // If no more unknown cards, switch back to normal mode
                if (unknownCards.length === 0) {
                    isReviewingUnknown = false;
                    reviewIndex = 0;
                    currentCardIndex = (currentCardIndex + 1) % filteredData.length;
                } else {
                    // Stay in review mode but move to next card
                    reviewIndex = reviewIndex % unknownCards.length;
                }
            } else {
                index = currentCardIndex;
                knownCards.add(index);
                // Remove from unknown if it was there
                const unknownIndex = unknownCards.indexOf(index);
                if (unknownIndex !== -1) {
                    unknownCards.splice(unknownIndex, 1);
                }
                currentCardIndex = (currentCardIndex + 1) % filteredData.length;
                
                // If we've completed all cards and there are unknown ones, start reviewing
                if (currentCardIndex === 0 && unknownCards.length > 0) {
                    isReviewingUnknown = true;
                    reviewIndex = 0;
                }
            }
            
            flashcard.classList.remove('flipped');
            updateFlashcard();
        });

        // Handle "I Don't Know" button
        dontKnowButton.addEventListener('click', () => {
            const filteredData = getFilteredStudyData();
            if (filteredData.length === 0) return;
            
            let index;
            if (isReviewingUnknown) {
                index = unknownCards[reviewIndex];
                // Move to next card in review
                reviewIndex = (reviewIndex + 1) % unknownCards.length;
            } else {
                index = currentCardIndex;
                // Add to unknown cards if not already there
                if (!unknownCards.includes(index)) {
                    unknownCards.push(index);
                }
                // Remove from known cards if it was there
                if (knownCards.has(index)) {
                    knownCards.delete(index);
                }
                currentCardIndex = (currentCardIndex + 1) % filteredData.length;
                
                // If we've completed all cards, start reviewing unknown ones
                if (currentCardIndex === 0 && unknownCards.length > 0) {
                    isReviewingUnknown = true;
                    reviewIndex = 0;
                }
            }
            
            flashcard.classList.remove('flipped');
            updateFlashcard();
        });

        prevCardButton.addEventListener('click', () => {
            const filteredData = getFilteredStudyData();
            if (filteredData.length === 0) return;
            
            if (isReviewingUnknown) {
                reviewIndex = (reviewIndex - 1 + unknownCards.length) % unknownCards.length;
            } else {
                currentCardIndex = (currentCardIndex - 1 + filteredData.length) % filteredData.length;
            }
            flashcard.classList.remove('flipped');
            updateFlashcard();
        });

        nextCardButton.addEventListener('click', () => {
            const filteredData = getFilteredStudyData();
            if (filteredData.length === 0) return;
            
            if (isReviewingUnknown) {
                reviewIndex = (reviewIndex + 1) % unknownCards.length;
            } else {
                currentCardIndex = (currentCardIndex + 1) % filteredData.length;
            }
            flashcard.classList.remove('flipped');
            updateFlashcard();
        });

        // Multiple choice functionality
        checkMCButton.addEventListener('click', () => {
            const selectedOption = document.querySelector('.option.selected');
            if (!selectedOption) {
                mcResult.textContent = 'Please select an answer.';
                mcResult.className = 'result incorrect';
                mcResult.style.display = 'block';
                return;
            }
            
            const isCorrect = selectedOption.getAttribute('data-correct') === 'true';
            if (isCorrect) {
                mcResult.textContent = 'Correct! Well done.';
                mcResult.className = 'result correct';
            } else {
                mcResult.textContent = 'Incorrect. Try again.';
                mcResult.className = 'result incorrect';
            }
            mcResult.style.display = 'block';
        });

        prevMCButton.addEventListener('click', () => {
            updateMCQuestion();
        });

        nextMCButton.addEventListener('click', () => {
            updateMCQuestion();
        });

        // Matching functionality
        function setupMatching() {
            const matchItems = document.querySelectorAll('.match-item');
            
            matchItems.forEach(item => {
                item.addEventListener('click', () => {
                    // Check if item is in the terms column
                    if (item.parentElement.id === 'terms-column') {
                        // Deselect all other terms
                        document.querySelectorAll('#terms-column .match-item').forEach(term => {
                            term.classList.remove('selected');
                        });
                        
                        // Select this term
                        item.classList.add('selected');
                        selectedTerm = item;
                    } 
                    // Check if item is in the definitions column
                    else if (item.parentElement.id === 'definitions-column') {
                        // Deselect all other definitions
                        document.querySelectorAll('#definitions-column .match-item').forEach(def => {
                            def.classList.remove('selected');
                        });
                        
                        // Select this definition
                        item.classList.add('selected');
                        selectedDefinition = item;
                    }
                    
                    // If both a term and a definition are selected, check if they match
                    if (selectedTerm && selectedDefinition) {
                        const termId = selectedTerm.getAttribute('data-id');
                        const definitionId = selectedDefinition.getAttribute('data-id');
                        
                        if (termId === definitionId) {
                            // Correct match
                            selectedTerm.style.background = 'var(--success)';
                            selectedDefinition.style.background = 'var(--success)';
                            selectedTerm.classList.remove('selected');
                            selectedDefinition.classList.remove('selected');
                            
                            // Store the match
                            matches[termId] = true;
                            
                            // Reset selections
                            selectedTerm = null;
                            selectedDefinition = null;
                            
                            // Check if all matches are complete
                            if (Object.keys(matches).length === currentMatchingSet.length) {
                                matchingResult.textContent = 'All matches are correct! Well done.';
                                matchingResult.className = 'result correct';
                                matchingResult.style.display = 'block';
                            }
                        } else {
                            // Incorrect match - flash red and then reset
                            selectedTerm.style.background = 'var(--error)';
                            selectedDefinition.style.background = 'var(--error)';
                            
                            setTimeout(() => {
                                selectedTerm.style.background = '';
                                selectedDefinition.style.background = '';
                                selectedTerm.classList.remove('selected');
                                selectedDefinition.classList.remove('selected');
                                selectedTerm = null;
                                selectedDefinition = null;
                            }, 1000);
                        }
                    }
                });
            });
        }

        checkMatchingButton.addEventListener('click', () => {
            // Check if all matches are correct
            const allMatched = Object.keys(matches).length === currentMatchingSet.length;
            
            if (allMatched) {
                matchingResult.textContent = 'All matches are correct! Well done.';
                matchingResult.className = 'result correct';
            } else {
                matchingResult.textContent = 'Some matches are incorrect. Keep trying!';
                matchingResult.className = 'result incorrect';
            }
            matchingResult.style.display = 'block';
        });

        // Text input functionality
        function updateTextQuestion() {
            const filteredData = getFilteredStudyData();
            if (filteredData.length === 0) {
                textQuestion.textContent = "No questions available with current filter";
                currentTextQuestionObject = null; // Clear question object
                return;
            }
            
            const currentText = filteredData[currentTextIndex];
            
            // Check if the term has specific questions
            if (currentText.questions && currentText.questions.length > 0) {
                // Select a random question object
                currentTextQuestionObject = currentText.questions[Math.floor(Math.random() * currentText.questions.length)];
            } else {
                // Fallback to default definition question
                currentTextQuestionObject = {
                    q: `What is the definition of "${currentText.term}"?`,
                    a: currentText.definition
                };
            }
            
            // Set the question text from the chosen object
            textQuestion.textContent = currentTextQuestionObject.q;
            
            // Reset answer field and results
            textAnswer.value = '';
            textResult.style.display = 'none';
            correctAnswer.style.display = 'none';
        }

        // Check text button listener
        checkTextButton.addEventListener('click', () => {
            if (!currentTextQuestionObject) {
                console.error("No currentTextQuestionObject is set.");
                return;
            }
            
            const userAnswer = textAnswer.value.trim().toLowerCase();
            const correctAns = currentTextQuestionObject.a.toLowerCase();
            
            // Simple check - in a real app you might use more advanced string similarity
            if (userAnswer === correctAns) {
                textResult.textContent = 'Correct! Well done.';
                textResult.className = 'result correct';
                correctAnswer.style.display = 'none';
            } else {
                textResult.textContent = 'Not quite right. The correct answer is:';
                textResult.className = 'result incorrect';
                // Show the specific correct answer from the question object
                correctAnswer.textContent = currentTextQuestionObject.a; 
                correctAnswer.style.display = 'block';
            }
            textResult.style.display = 'block';
        });

        prevTextButton.addEventListener('click', () => {
            const filteredData = getFilteredStudyData();
            if (filteredData.length === 0) return;
            
            currentTextIndex = (currentTextIndex - 1 + filteredData.length) % filteredData.length;
            updateTextQuestion(); // This will pick a new random question for the new term
        });

        nextTextButton.addEventListener('click', () => {
            const filteredData = getFilteredStudyData();
            if (filteredData.length === 0) return;
            
            currentTextIndex = (currentTextIndex + 1) % filteredData.length;
            updateTextQuestion(); // This will pick a new random question for the new term
        });

        // Revision content generation - UPDATED TO SHOW ALL DATA
        function generateRevisionContent() {
            revisionContent.innerHTML = '';
            
            const filteredData = getFilteredStudyData();
            if (filteredData.length === 0) {
                revisionContent.innerHTML = '<p>No revision materials available with current filter</p>';
                return;
            }
            
            filteredData.forEach(item => {
                const revisionItem = document.createElement('div');
                revisionItem.classList.add('revision-item');
                
                let contentHTML = `<div class="revision-term">${item.term}`;
                
                // Add tag indicators
                if (item.tags && item.tags.length) {
                    item.tags.forEach(tag => {
                        let tagClass = '';
                        if (tag === 'Information Representation') tagClass = 'tag-info-rep';
                        if (tag === 'Multimedia') tagClass = 'tag-multimedia';
                        if (tag === 'Files') tagClass = 'tag-files';
                        if (tag === 'Processor') tagClass = 'tag-processor';
                        
                        contentHTML += `<span class="tag-indicator ${tagClass}">${tag}</span>`;
                    });
                }
                
                contentHTML += `</div>`;
                
                // Add all properties from the study item
                const propertiesToShow = [
                    'definition', 'details', 'example', 'applications', 'benefits',
                    'conversion', 'reverseConversion', 'range', 'standards', 'tradeoff',
                    'similarities', 'encoding', 'properties', 'effect', 'formula',
                    'fileHeader', 'drawingList', 'scalability', 'pixels', 'analogueVsDigital',
                    'fileSize', 'limitations', 'methods'
                ];
                
                propertiesToShow.forEach(prop => {
                    if (item[prop]) {
                        // Format property name for display
                        const displayName = prop.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                        contentHTML += `
                            <div class="revision-property">
                                <div class="revision-property-title">${displayName}:</div>
                                <div>${item[prop]}</div>
                            </div>
                        `;
                    }
                });
                
                // Add questions if available
                if (item.questions && item.questions.length > 0) {
                    contentHTML += `<div class="revision-property">
                        <div class="revision-property-title">Questions:</div>`;
                    
                    item.questions.forEach(qa => {
                        contentHTML += `<div><strong>Q:</strong> ${qa.q}<br><strong>A:</strong> ${qa.a}</div>`;
                    });
                    
                    contentHTML += `</div>`;
                }
                
                revisionItem.innerHTML = contentHTML;
                revisionContent.appendChild(revisionItem);
            });
        }

        // PDF Generation Function
        function generatePDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            const filteredData = getFilteredStudyData();
            if (filteredData.length === 0) {
                alert("No content available to generate PDF with current filter");
                return;
            }
            
            // Set initial position
            let yPosition = 20;
            const pageHeight = doc.internal.pageSize.height;
            const margin = 20;
            const lineHeight = 7;
            
            // Add title
            doc.setFontSize(20);
            doc.setTextColor(0, 170, 255);
            doc.text("Codem's Study Hub - Revision Notes", margin, yPosition);
            yPosition += 15;
            
            // Add filter info
            doc.setFontSize(12);
            doc.setTextColor(255, 255, 255);
            const filterText = selectedTopic === "all" ? "All Topics" : selectedTopic;
            doc.text(`Topic Filter: ${filterText}`, margin, yPosition);
            yPosition += 10;
            
            // Add date
            const now = new Date();
            doc.text(`Generated on: ${now.toLocaleDateString()} ${now.toLocaleTimeString()}`, margin, yPosition);
            yPosition += 15;
            
            // Set properties to include
            const propertiesToShow = [
                'definition', 'details', 'example', 'applications', 'benefits',
                'conversion', 'reverseConversion', 'range', 'standards', 'tradeoff',
                'similarities', 'encoding', 'properties', 'effect', 'formula',
                'fileHeader', 'drawingList', 'scalability', 'pixels', 'analogueVsDigital',
                'fileSize', 'limitations', 'methods'
            ];
            
            // Loop through each study item
            filteredData.forEach((item, index) => {
                // Check if we need a new page
                if (yPosition > pageHeight - 50) {
                    doc.addPage();
                    yPosition = 20;
                }
                
                // Add term as heading
                doc.setFontSize(16);
                doc.setTextColor(0, 170, 255);
                doc.text(item.term, margin, yPosition);
                yPosition += 10;
                
                // Add tags if available
                if (item.tags && item.tags.length) {
                    doc.setFontSize(10);
                    doc.setTextColor(200, 200, 255);
                    const tagsText = `Tags: ${item.tags.join(', ')}`;
                    doc.text(tagsText, margin, yPosition);
                    yPosition += 7;
                }
                
                // Reset text color
                doc.setTextColor(0, 0, 0);
                
                // Add properties
                propertiesToShow.forEach(prop => {
                    if (item[prop]) {
                        // Check if we need a new page
                        if (yPosition > pageHeight - 30) {
                            doc.addPage();
                            yPosition = 20;
                        }
                        
                        // Format property name
                        const displayName = prop.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                        
                        // Add property title
                        doc.setFontSize(12);
                        doc.setFont(undefined, 'bold');
                        doc.text(`${displayName}:`, margin, yPosition);
                        yPosition += 6;
                        
                        // Add property content
                        doc.setFont(undefined, 'normal');
                        
                        // Split text into lines that fit the page width
                        const splitText = doc.splitTextToSize(item[prop], doc.internal.pageSize.width - 2 * margin);
                        doc.text(splitText, margin, yPosition);
                        yPosition += splitText.length * lineHeight + 5;
                    }
                });
                
                // Add questions if available
                if (item.questions && item.questions.length > 0) {
                    if (yPosition > pageHeight - 50) {
                        doc.addPage();
                        yPosition = 20;
                    }
                    
                    doc.setFontSize(12);
                    doc.setFont(undefined, 'bold');
                    doc.text('Questions:', margin, yPosition);
                    yPosition += 6;
                    
                    doc.setFont(undefined, 'normal');
                    item.questions.forEach(qa => {
                        if (yPosition > pageHeight - 30) {
                            doc.addPage();
                            yPosition = 20;
                        }
                        
                        const qText = `Q: ${qa.q}`;
                        const aText = `A: ${qa.a}`;
                        
                        const splitQ = doc.splitTextToSize(qText, doc.internal.pageSize.width - 2 * margin);
                        doc.text(splitQ, margin, yPosition);
                        yPosition += splitQ.length * lineHeight;
                        
                        const splitA = doc.splitTextToSize(aText, doc.internal.pageSize.width - 2 * margin);
                        doc.text(splitA, margin, yPosition);
                        yPosition += splitA.length * lineHeight + 5;
                    });
                }
                
                // Add space between items
                yPosition += 10;
                
                // Add a separator line
                if (index < filteredData.length - 1) {
                    doc.line(margin, yPosition, doc.internal.pageSize.width - margin, yPosition);
                    yPosition += 10;
                }
            });
            
            // Save the PDF
            const fileName = `Codem_Study_Notes_${filterText.replace(/\s+/g, '_')}_${now.getTime()}.pdf`;
            doc.save(fileName);
        }

        // Initialize the application
        loadStudyData();
        
        // Event listener for new matching set button
        newMatchingSetButton.addEventListener('click', generateMatchingSet);
        
        // Event listener for PDF download button
        downloadPdfButton.addEventListener('click', generatePDF);
    </script>
</body>
</html>
